<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/lightbox2/dist/css/lightbox.min.css" rel="stylesheet">
    <title>Statistics - Homework 9</title>
    <style>
        /* Font Google Import */
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f0f4f8;
            color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            background-color: #fff;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            max-width: 1000px; /* Aumentato per dare più spazio */
            width: 100%;
            position: relative;
        }

        h1 {
            color: #34495e;
            font-weight: 700;
            text-align: center;
            margin-top: 30px;
            margin-bottom: 30px;
        }

        h2 {
            color: #34495e;
            font-weight: 700;
            margin-top: 40px;
            margin-bottom: 20px;
        }

        h3,h4 {
            margin-bottom: 10px; /* Spazio tra il titolo e il paragrafo */
        }

        p {
            margin-bottom: 20px; /* Spazio tra un paragrafo e l'altro */
        }

        .theory-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px; /* Spazio tra il titolo/link e il resto del contenuto */
}

.go-practice {
    color: #3498db;
    text-decoration: none;
    font-weight: 500;
    transition: color 0.3s ease;
}

.go-practice:hover {
    color: #2980b9;
}

/* Responsive adjustments */
@media (max-width: 600px) {
    .theory-header {
        flex-direction: column;
        align-items: flex-start;
    }

    .go-practice {
        margin-top: 10px;
    }
}

        ul, ol {
            padding-left: 20px; /* Aggiunge padding per allineare con il paragrafo */
        }

        .index {
            margin-bottom: 40px;
        }

        .index ul {
            list-style-type: none;
            padding-left: 0;
        }

        .index ul li {
            margin: 10px 0;
        }

        .index ul li a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .index ul li a:hover {
            color: #2980b9;
        }

        /* Link to home */
        .back-home {
            position: absolute;
            top: 20px;
            left: 20px;
        }

        .back-home a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
            font-size: 0.9em;
            transition: color 0.3s ease;
        }

        .back-home a:hover {
            color: #2980b9;
        }

        /* Section styles */
        section {
            margin-bottom: 40px;
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 1.5em;
            }

            h2 {
                font-size: 1.2em;
            }

            .back-home a {
                font-size: 0.8em;
            }
        }

        /* Styling for the Show Code button */
        button {
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: background-color 0.3s ease, transform 0.3s ease;
        margin-bottom: 15px;
        }

        /* Button hover effect */
        button:hover {
        background-color: #2980b9;
        transform: translateY(-2px);
        }

        /* Add spacing between button and next paragraph */
        button + p {
        margin-top: 20px;
        }

        /* Style for the code block when it is shown */
        pre {
        background-color: #ecf0f1;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        overflow-x: auto;
        }

        /* Code block indentation */
        code {
        font-family: 'Courier New', monospace;
        font-size: 0.95em;
        }

    </style>

<script>
    MathJax = {
        tex: {
            inlineMath: [['\\(', '\\)']],
            displayMath: [['\\[', '\\]']]
        },
        svg: { fontCache: 'global' }
    };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>
    <div class="container">
        <!-- Link per tornare alla home -->
        <div class="back-home">
            <a href="index.html">&larr; <strong>Back to Home</strong></a>
        </div>

        <h1>Statistics - Homework 9</h1>

<section id="theory">
    <div class="theory-header">
        <h2>Theory</h2>
        <a class="go-practice" href="#practice">Go to Practice</a>
    </div>
    
    <h3>Properties of the Sampling Mean and Variance</h3>
    <p>
        The sampling mean \( \bar{X} \) and sampling variance \( S^2 \) are key statistics derived from a sample of size \( n \). Their main properties are:
    </p>
    <ul>
        <li>
            <strong>Sampling Mean:</strong>
            <ul>
                <li>\( \mathbb{E}[\bar{X}] = \mu \), where \( \mu \) is the population mean. This indicates that the sampling mean is an unbiased estimator of the population mean.</li>
                <li>\( \text{Var}[\bar{X}] = \frac{\sigma^2}{n} \), where \( \sigma^2 \) is the population variance. The variance of the sampling mean decreases as the sample size increases.</li>
            </ul>
        </li>
        <li>
            <strong>Sampling Variance:</strong>
            <ul>
                <li>\( \mathbb{E}[S^2] = \sigma^2 \) (for the unbiased sample variance). This makes the sample variance an unbiased estimator of the population variance.</li>
                <li>The distribution of \( S^2 \) depends on the sample size \( n \) and the underlying population distribution.</li>
            </ul>
        </li>
    </ul>

    <p></p>

    <h3>Law of Large Numbers and Possible Applications</h3>
    <p>
        The Law of Large Numbers (LLN) states that as the sample size \( n \) increases, the sample mean \( \bar{X} \) converges to the population mean \( \mu \):
    </p>
    <div style="text-align: center;">
        \[
        \lim_{n \to \infty} \bar{X} = \mu
        \]
    </div>
    <p>
        This principle ensures that large samples provide reliable estimates of population parameters, which has applications across various fields.
    </p>
    <h4>Applications in Cybersecurity</h4>
    <ul>
        <li>
            <strong>Entropy Estimation:</strong> In cryptographic systems, accurate estimation of entropy in random number generators ensures robust security. The LLN helps assess the expected entropy over multiple samples.
        </li>
        <li>
            <strong>Anomaly Detection:</strong> Monitoring mean and variance of network traffic over time can reveal deviations indicative of attacks or intrusions.
        </li>
        <li>
            <strong>Key Distribution Analysis:</strong> Evaluating uniformity in key distribution in cryptographic protocols ensures secure and unbiased key generation.
        </li>
        <li>
            <strong>Side-Channel Attacks:</strong> LLN assists in analyzing large datasets of power or timing measurements to detect patterns and mitigate risks in cryptographic implementations.
        </li>
    </ul>
</section>


<section id="theory2">
    
    <h3>Encryption Methods and Statistical Properties (optional)</h3>
    <p>
        Encryption methods are fundamental to securing data in communications and storage. They transform plaintext into ciphertext, making the data unreadable without the correct decryption key. Below are the main encryption methods and their statistical properties:
    </p>
    
    <h4>1. Substitution Ciphers</h4>
    <p>
        A substitution cipher replaces each letter or symbol in the plaintext with another. The most famous example is the Caesar cipher. 
        Its statistical property is that frequency analysis can reveal patterns in the ciphertext, as the relative frequency of letters remains similar to that of the plaintext.
    </p>
    
    <h4>2. Transposition Ciphers</h4>
    <p>
        A transposition cipher rearranges the letters in the plaintext according to a specific system. Unlike substitution ciphers, frequency distributions of letters remain unchanged, but their positions are shuffled. Analyzing the structure and patterns of ciphertext can still provide insights into the key.
    </p>
    
    <h4>3. Symmetric Key Encryption (e.g., AES)</h4>
    <p>
        Symmetric encryption uses the same key for both encryption and decryption. The Advanced Encryption Standard (AES) is a widely used symmetric encryption method. Its statistical properties are designed to minimize patterns in the ciphertext, ensuring that it appears as random noise. Good encryption schemes, such as AES, make frequency analysis infeasible and ensure a low correlation between plaintext and ciphertext.
    </p>
    
    <h4>4. Asymmetric Key Encryption (e.g., RSA)</h4>
    <p>
        Asymmetric encryption uses a pair of keys: a public key for encryption and a private key for decryption. RSA is the most well-known asymmetric encryption algorithm. The statistical property of RSA is that the ciphertext has no obvious relationship to the plaintext and is computationally difficult to decrypt without the private key. Its security relies on the difficulty of factoring large prime numbers.
    </p>
    
    <h4>5. Stream Ciphers (e.g., RC4)</h4>
    <p>
        Stream ciphers encrypt plaintext one bit or byte at a time, typically by combining it with a pseudorandom stream of bits (keystream). Statistical properties include resistance to frequency analysis, but weak implementations or poor keystream generation can introduce vulnerabilities. When the keystream repeats or is predictable, ciphertext may become vulnerable to attacks.
    </p>
    
    <h4>Statistical Properties of Strong Encryption</h4>
    <p>
        The effectiveness of an encryption method is often determined by its ability to obscure statistical properties of the plaintext. Strong encryption schemes aim to:
    </p>
    <ul>
        <li>Ensure ciphertext appears random and unrelated to the plaintext distribution.</li>
        <li>Minimize any patterns or correlations that could be exploited by attackers (e.g., frequency analysis, known-plaintext attacks).</li>
        <li>Provide resistance against cryptanalysis techniques, ensuring that breaking the encryption requires significant computational effort.</li>
    </ul>
</section>



    <section id="practice">
        <div class="theory-header">
            <h2>Practice</h2>
            <a class="go-practice" href="#theory">Go to Theory</a>
        </div>

        <h2>Part 1</h2>
        <p>
            Following the same scheme of HMWK 7 compute the distribution of the sampling variance ("corrected" or not). Determine the distribution of the variances of the samples, and its mean and variance. Discussing the observed relationship with the mean and variance of the parent (theoretical) distribution.
        </p>

        <h3>Application's Key Features</h3>
<ul>
    <li><strong>Parent Distribution</strong>: Defines a discrete probability distribution with specific probabilities (e.g., 0.2, 0.3, 0.5) for values (0, 1, 2) used to generate random samples.</li>
    <li><strong>Sampling Process</strong>: Generates m random samples, each of size n, and computes the variance for each sample. Users can choose corrected (Bessel's correction) or uncorrected variance.</li>
    <li><strong>Variance Calculation</strong>: Computes the sample variance (corrected or uncorrected), the mean of sample variances, and the variance of those variances. It also calculates the theoretical variance of the parent distribution.</li>
    <li><strong>Plotting</strong>: Visualizes the distribution of sample variances using a bar chart. The horizontal axis represents bins of variance values, while the vertical axis represents the frequency of occurrences in each bin.</li>
    <li><strong>User Interface</strong>: Includes TextBoxes for user input (number of samples, sample size, corrected variance option), Labels for displaying computed statistics, and a PlotView for displaying the variance distribution chart.</li>
</ul>

        
        <p></p>
        
<!-- Button to show/hide code -->
<button onclick="toggleCode('simulationCode')">Show Code</button>
<div id="simulationCode" style="display: none;">
<pre>
    private List<int> GenerateSample(int n)
    {
        var sample = new List<int>();
        for (int i = 0; i < n; i++)
        {
            sample.Add(GenerateSingleEvent());
        }
        return sample;
    }

    private int GenerateSingleEvent()
    {
        double r = random.NextDouble();
        double cumulative = 0.0;

        for (int i = 0; i < probabilities.Count; i++)
        {
            cumulative += probabilities[i];
            if (r < cumulative)
            {
                return i;
            }
        }
        return probabilities.Count - 1;
    }

    private double SampleVariance(List<int> sample, bool corrected = true)
    {
        double mean = sample.Average();
        double variance = sample.Sum(x => Math.Pow(x - mean, 2));
        return corrected ? variance / (sample.Count - 1) : variance / sample.Count;
    }

    private double Variance(List<double> values)
    {
        double mean = values.Average();
        return values.Sum(v => Math.Pow(v - mean, 2)) / (values.Count - 1);
    }

    private double TheoreticalVariance()
    {
        double mean = Enumerable.Range(0, probabilities.Count)
                                .Select(i => i * probabilities[i])
                                .Sum();
        return Enumerable.Range(0, probabilities.Count)
                        .Select(i => probabilities[i] * Math.Pow(i - mean, 2))
                        .Sum();
    }

    private void UpdatePlot(List<double> sampleVariances)
    {
        plotModel.Series.Clear();

        int numBins = 20;
        double min = sampleVariances.Min();
        double max = sampleVariances.Max();
        double binWidth = (max - min) / numBins;

        // Calcolo delle frequenze
        double[] bins = new double[numBins];
        foreach (var variance in sampleVariances)
        {
            int binIndex = (int)((variance - min) / binWidth);
            if (binIndex == numBins) binIndex--; // Gestione casi limite
            bins[binIndex]++;
        }

        // Crea intervalli di varianza come categorie
        var varianceCategories = new List<string>();
        for (int i = 0; i < numBins; i++)
        {
            double start = min + i * binWidth;
            double end = start + binWidth;
            varianceCategories.Add($"{start:F2} - {end:F2}");
        }

        // Configura l'asse CategoryAxis con gli intervalli
        var categoryAxis = plotModel.Axes.OfType<OxyPlot.Axes.CategoryAxis>().First();
        categoryAxis.ItemsSource = varianceCategories;

        // Popola la serie Bar con le frequenze
        var barSeries = new BarSeries
        {
            Title = "Sampling Variance Distribution",
            StrokeColor = OxyColors.Black,
            StrokeThickness = 1,
            FillColor = OxyColor.FromRgb(30, 144, 255)
        };

        for (int i = 0; i < numBins; i++)
        {
            barSeries.Items.Add(new OxyPlot.Series.BarItem { Value = bins[i] });
        }

        plotModel.Series.Add(barSeries);

        // Aggiorna il grafico
        plotModel.InvalidatePlot(true);
    }
</pre>
</div>

<h3>Final Result</h3>
<p>
    Here is a screenshot that shows the ouput of the application with m = 1000 and n = 30.
</p>

<a href="HW9_part1.png" data-lightbox="result">
    <img src="HW9_part1.png" style="max-width: 100%; height: auto; margin: 20px 0;">
</a>

<h3>Theoretical Reflections</h3>

<h4>Sample Mean vs. Theoretical Mean:</h4>
<ul>
    <li>The sample mean is an unbiased estimator of the theoretical mean of the parent distribution.</li>
    <li>As the sample size increases, the sample mean converges to the theoretical mean due to the <strong>Law of Large Numbers</strong>.</li>
    <li>For small sample sizes, random fluctuations can cause the sample mean to deviate from the theoretical mean.</li>
</ul>
<br>
<h4>Sample Variance vs. Theoretical Variance:</h4>
<ul>
    <li>The sample variance (when corrected by dividing by <em>n-1</em>) is an unbiased estimator of the theoretical variance of the parent distribution.</li>
    <li>This correction compensates for the bias introduced by using the sample mean instead of the true mean in the variance calculation.</li>
    <li>The uncorrected sample variance (dividing by <em>n</em>) underestimates the true variance, particularly for small sample sizes.</li>
</ul>
<br>
<h4>Effect of Sample Size:</h4>
<ul>
    <li>Larger sample sizes reduce the variability of both the sample mean and sample variance, leading to more precise estimates of the theoretical values.</li>
    <li>For small sample sizes, both the sample mean and variance are more prone to random fluctuations, resulting in greater discrepancies from the theoretical values.</li>
</ul>



<br>

<h2>Part 2 (optional)</h2>
        

        <h3>Application's Key Features</h3>
<ul>
    <li>
        <strong>Substitution Cipher:</strong>
        <ul>
            <li>Implements a random one-to-one mapping of the alphabet (A-Z) to perform encryption.</li>
            <li>Each letter in the plaintext is replaced with its corresponding substitute based on the generated key.</li>
            <li>Demonstrates how substitution ciphers affect letter frequency, introducing randomness into the message.</li>
        </ul>
    </li>
    <li>
        <strong>Frequency Analysis:</strong>
        <ul>
            <li>Displays the frequency distribution of letters in the original (plaintext) and encrypted messages.</li>
            <li>Illustrates how substitution ciphers disrupt the frequency patterns of the original text.</li>
        </ul>
    </li>
    <li>
        <strong>Entropy Calculation:</strong>
        <ul>
            <li>Computes the Shannon entropy of the plaintext and encrypted text.</li>
            <li>Displays these values in separate text boxes, helping analyze how encryption increases message uncertainty.</li>
        </ul>
    </li>
    <li>
        <strong>Permutation Step:</strong>
        <ul>
            <li>Reverses the order of the encrypted text, adding an additional layer of encryption.</li>
            <li>Highlights how reordering impacts frequency patterns and entropy without changing individual letter substitutions.</li>
        </ul>
    </li>
    <li>
        <strong>Decryption:</strong>
        <ul>
            <li>Enables reversing the substitution and permutation steps to retrieve the original plaintext.</li>
            <li>Demonstrates the importance of knowing the encryption key for successful decryption.</li>
        </ul>
    </li>
</ul>


        
        <p></p>
        
<!-- Button to show/hide code -->
<button onclick="toggleCode('simulationCode2')">Show Code</button>
<div id="simulationCode2" style="display: none;">
<pre>
    private void GenerateSubstitutionKey()
    {
        substitutionKey = new Dictionary<char, char>();
        reverseKey = new Dictionary<char, char>();
        var letters = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".ToCharArray();
        var shuffled = letters.OrderBy(_ => Guid.NewGuid()).ToArray();

        for (int i = 0; i < letters.Length; i++)
        {
            substitutionKey[letters[i]] = shuffled[i];
            reverseKey[shuffled[i]] = letters[i];
        }
    }

    private string EncryptMessage(string message)
    {
        return new string(message.Select(ch =>
        {
            if (substitutionKey.ContainsKey(ch))
                return substitutionKey[ch];
            return ch; // Keep non-alphabetic characters unchanged
        }).ToArray());
    }

    private Dictionary<char, int> CalculateFrequency(string message)
    {
        var frequency = new Dictionary<char, int>();
        foreach (var ch in message)
        {
            if (char.IsLetter(ch))
            {
                if (!frequency.ContainsKey(ch))
                    frequency[ch] = 0;
                frequency[ch]++;
            }
        }
        return frequency;
    }

    private double CalculateEntropy(Dictionary<char, int> frequency)
    {
        int total = frequency.Values.Sum();
        return -frequency.Values
            .Where(count => count > 0)
            .Select(count => (double)count / total)
            .Sum(p => p * Math.Log2(p));
    }

    private string DecryptMessage(string message)
    {
        return new string(message.Select(ch =>
        {
            if (reverseKey.ContainsKey(ch))
                return reverseKey[ch];
            return ch; // Keep non-alphabetic characters unchanged
        }).ToArray());
    }

</pre>
</div>

<h3>Final Result</h3>
<p>
    Here is a screenshot that shows the ouput of the application.
</p>

<a href="HW9_part2.png" data-lightbox="result">
    <img src="HW9_part2.png" style="max-width: 100%; height: auto; margin: 20px 0;">
</a>

<h3>Theoretical Reflections</h3>

<h4>1. How the Substitution Cipher Affects the Distribution of Letters</h4>
<p>
The substitution cipher changes the mapping of each letter in the plaintext to a corresponding letter in the ciphertext according to a predefined substitution key. This transformation alters the frequency distribution of the original letters while preserving the relative frequencies. For instance, if 'E' was the most frequent letter in the plaintext, its substitute (e.g., 'I' in this case) will appear most frequently in the ciphertext. This means the overall statistical patterns are retained, though obscured. However, such a cipher is vulnerable to frequency analysis, as the distribution of letter frequencies remains similar between the plaintext and ciphertext.
</p>

<h4>2. How Substitution Affects Uncertainty or Randomness in the Message</h4>
<p>
The substitution cipher does not significantly affect the entropy (measure of uncertainty or randomness) of the message, as seen in the output where both the original and encrypted messages have an entropy of <strong>3.4464</strong>. This is because substitution does not introduce new randomness; it simply remaps the letters while maintaining their frequency. Hence, the predictability of the message, based on letter distribution, remains relatively unchanged.
</p>

<h4>3. Effect of Reversing the Order of Letters</h4>
<p>
Reversing the order of letters does not change the frequency distribution or entropy of the message, as it only rearranges the sequence of characters. The frequency of individual letters (e.g., 'E' appearing 3 times in the original and encrypted texts) remains constant. However, reversing the message can obscure patterns like repeated bigrams or trigrams (e.g., common digraphs like 'TH' or 'ER'), making it marginally harder for attackers relying on such patterns. Yet, this technique alone does not add significant security since the underlying frequency distribution is unaltered.
</p>

<h4>4. Frequency Distribution Changes After Permutation</h4>
<p>
The permutation step (substitution in this case) remaps letters but keeps the overall frequency structure intact. This means statistical analysis can still be applied to deduce the substitution key by comparing the ciphertext's letter frequencies to standard frequency tables (e.g., the frequency of 'E' in English text). The significance of this change is that while it obscures the direct readability of the text, it does not eliminate statistical patterns that can aid cryptanalysis. This highlights the weakness of substitution ciphers when used without additional layers of encryption.
</p>

<h4>5. Entropy Considerations</h4>
<p>
The original and encrypted messages have the same entropy of <strong>3.4464</strong>, indicating no increase in randomness or unpredictability. This shows that the substitution cipher does not enhance the intrinsic security of the message against entropy-based attacks. A higher entropy would imply greater unpredictability and, therefore, increased security. For robust cryptographic systems, increasing entropy is essential to thwart statistical or brute-force attacks.
</p>

<h4>6. Contrast with RSA Concepts</h4>
<p>
Unlike substitution ciphers, RSA encryption relies on mathematical principles (e.g., modular arithmetic and prime factorization) and does not inherently preserve frequency distribution. RSA encrypts data at the level of blocks or numerical representations, which breaks statistical patterns. Additionally, RSA’s security lies in its key management and computational infeasibility of key recovery, not on altering letter frequencies. While substitution ciphers can be cracked with frequency analysis, RSA’s use of public-private key pairs ensures a high level of difficulty in decryption without the private key.
</p>

<h4>7. Final Thoughts on Entropy and Security</h4>
<p>
Entropy is a critical metric in cryptography as it quantifies the unpredictability of a message. Higher entropy in an encrypted message makes it harder for attackers to predict patterns or reconstruct plaintext. Substitution ciphers fail to increase entropy and thus provide minimal security. In contrast, modern encryption algorithms like AES or RSA aim to maximize entropy to obscure patterns and enhance resistance to cryptanalysis. A secure encryption scheme should strive to distribute entropy uniformly across the message, ensuring no discernible statistical patterns remain.
</p>





<script>
// JavaScript function to toggle visibility of code sections
function toggleCode(id) {
    var codeBlock = document.getElementById(id);
    if (codeBlock.style.display === "none") {
        codeBlock.style.display = "block";
    } else {
        codeBlock.style.display = "none";
    }
}
</script>
    
    </section>

    <script src="https://cdn.jsdelivr.net/npm/lightbox2/dist/js/lightbox-plus-jquery.min.js"></script>
</body>
</html>
