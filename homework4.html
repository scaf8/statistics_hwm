<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link href="https://cdn.jsdelivr.net/npm/lightbox2/dist/css/lightbox.min.css" rel="stylesheet">
    <title>Statistics - Homework 4</title>
    <style>
        /* Font Google Import */
        @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;500;700&display=swap');

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Roboto', sans-serif;
            background-color: #f0f4f8;
            color: #2c3e50;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
        }

        .container {
            background-color: #fff;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.1);
            max-width: 1000px; /* Aumentato per dare più spazio */
            width: 100%;
            position: relative;
        }

        h1 {
            color: #34495e;
            font-weight: 700;
            text-align: center;
            margin-top: 30px;
            margin-bottom: 30px;
        }

        h2 {
            color: #34495e;
            font-weight: 700;
            margin-top: 40px;
            margin-bottom: 20px;
        }

        h3,h4 {
            margin-bottom: 10px; /* Spazio tra il titolo e il paragrafo */
        }

        p {
            margin-bottom: 20px; /* Spazio tra un paragrafo e l'altro */
        }

        .theory-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px; /* Spazio tra il titolo/link e il resto del contenuto */
}

.go-practice {
    color: #3498db;
    text-decoration: none;
    font-weight: 500;
    transition: color 0.3s ease;
}

.go-practice:hover {
    color: #2980b9;
}

/* Responsive adjustments */
@media (max-width: 600px) {
    .theory-header {
        flex-direction: column;
        align-items: flex-start;
    }

    .go-practice {
        margin-top: 10px;
    }
}

        ul, ol {
            padding-left: 20px; /* Aggiunge padding per allineare con il paragrafo */
        }

        .index {
            margin-bottom: 40px;
        }

        .index ul {
            list-style-type: none;
            padding-left: 0;
        }

        .index ul li {
            margin: 10px 0;
        }

        .index ul li a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
            transition: color 0.3s ease;
        }

        .index ul li a:hover {
            color: #2980b9;
        }

        /* Link to home */
        .back-home {
            position: absolute;
            top: 20px;
            left: 20px;
        }

        .back-home a {
            color: #3498db;
            text-decoration: none;
            font-weight: 500;
            font-size: 0.9em;
            transition: color 0.3s ease;
        }

        .back-home a:hover {
            color: #2980b9;
        }

        /* Section styles */
        section {
            margin-bottom: 40px;
        }

        /* Responsive Design */
        @media (max-width: 600px) {
            .container {
                padding: 20px;
            }

            h1 {
                font-size: 1.5em;
            }

            h2 {
                font-size: 1.2em;
            }

            .back-home a {
                font-size: 0.8em;
            }
        }

        /* Styling for the Show Code button */
        button {
        background-color: #3498db;
        color: white;
        border: none;
        border-radius: 5px;
        padding: 10px 20px;
        font-size: 1em;
        cursor: pointer;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        transition: background-color 0.3s ease, transform 0.3s ease;
        margin-bottom: 15px;
        }

        /* Button hover effect */
        button:hover {
        background-color: #2980b9;
        transform: translateY(-2px);
        }

        /* Add spacing between button and next paragraph */
        button + p {
        margin-top: 20px;
        }

        /* Style for the code block when it is shown */
        pre {
        background-color: #ecf0f1;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        overflow-x: auto;
        }

        /* Code block indentation */
        code {
        font-family: 'Courier New', monospace;
        font-size: 0.95em;
        }

    </style>

<script>
    MathJax = {
        tex: {
            inlineMath: [['\\(', '\\)']],
            displayMath: [['\\[', '\\]']]
        },
        svg: { fontCache: 'global' }
    };
</script>
<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>

</head>
<body>
    <div class="container">
        <!-- Link per tornare alla home -->
        <div class="back-home">
            <a href="index.html">&larr; <strong>Back to Home</strong></a>
        </div>

        <h1>Statistics - Homework 4</h1>

        <section id="theory">
            <div class="theory-header">
                <h2>Theory</h2>
                <a class="go-practice" href="#practice">Go to Practice</a>
            </div>
            
            <h3>Statistical Independence</h3>
            <p>
                Statistical independence is a fundamental concept in probability theory, indicating that the occurrence of one event does not influence the occurrence of another. Here's an illustration of the concept along with formal definitions and analogies.
            </p>

            <h4>Definition</h4>
            <p>
                Two events \(A\) and \(B\) are said to be statistically independent if the probability of both events occurring together is equal to the product of their individual probabilities. Mathematically, this is defined as:
                <br>
                \[ P(A \cap B) = P(A) \cdot P(B) \]
                <br>
                Where:
                <ul>
                    <li>\(P(A \cap B)\) is the probability that both events \(A\) and \(B\) occur.</li>
                    <li>\(P(A)\) is the probability of event \(A\) occurring</li>
                    <li>\(P(B)\) is the probability of event \(B\) occurring</li>
                </ul>
            </p>

            <h4>Examples</h4>
  <p>
    <b>1. Discrete Probability Example:</b><br>
    Consider a fair six-sided die.<br>
    Let \( A \) be the event "rolling an even number" (i.e., \( A = \\{2, 4, 6\\} \)).<br>
    Let \( B \) be the event "rolling a number greater than 3" (i.e., \( B = \\{4, 5, 6\\} \)).<br>
    <br>
    The probabilities are:
    \[
    P(A) = \frac{3}{6} = \frac{1}{2}, \quad P(B) = \frac{3}{6} = \frac{1}{2}
    \]
    The intersection \( A \cap B = \\{4, 6\\} \), so:
    \[
    P(A \cap B) = \frac{2}{6} = \frac{1}{3}
    \]
    Here, since \( P(A \cap B) \neq P(A) \cdot P(B) \), the events \( A \) and \( B \) are dependent.
  </p>

  <p>
    <b>2. Independent Events Example:</b><br>
    Now consider flipping a coin and rolling a die.<br>
    Let \( C \) be the event "the coin shows heads" and \( D \) be the event "rolling a 4".<br>
    <br>
    The probabilities are:
    \[
    P(C) = \frac{1}{2}, \quad P(D) = \frac{1}{6}
    \]
    Since the events are independent:
    \[
    P(C \cap D) = P(C) \cdot P(D) = \frac{1}{2} \cdot \frac{1}{6} = \frac{1}{12}
    \]
  </p>

  <h4>Key Points and Analogies</h4>
  <ul>
    <li><b>Independence vs. Dependence:</b> The key aspect of independence is the lack of influence. In our examples, \( A \) and \( B \) affected each other’s probabilities, while \( C \) and \( D \) did not.</li>
    <li><b>Joint Probability:</b> The joint probability \( P(A \cap B) \) reflects how two events interact. For independent events, the product rule holds; for dependent events, it does not.</li>
    <li><b>Generalization:</b> The concept can be generalized to more than two events. Events \( A_1, A_2, \ldots, A_n \) are independent if:
      \[
      P(A_1 \cap A_2 \cap \ldots \cap A_n) = P(A_1) \cdot P(A_2) \cdots P(A_n)
      \]
    </li>
  </ul>


        </section>

        <section id="practice">
            <div class="theory-header">
                <h2>Practice</h2>
                <a class="go-practice" href="#theory">Go to Theory</a>
            </div>

            <h3>Programming Exercise Overview</h3>
            <p>
                Refine your stochastic SDE simulator to generate a continuous time, process to represent the scaling limit of the random Walk. To create the approximation of time continuity subdivide your reference temporal window into vanishing intervals dt and on each infinitesimal interval assign a probability p or p to make a jump of a + or - sqrt(dt). Note the significance of the simulation (Donsker invariance principle/ theorem or the functional central limit theorem) in relation to the Wiener process.
            </p>
            
            <p></p>
            <!-- Sections explaining the code with show/hide buttons -->
            <h3>Code Explanation</h3>
            <p>
                Most of the code is the same as the previous homework. Below there are the only few relevant changes in this homework.
            </p>

<!-- Section 2: Simulation of Penetration -->
<h4>Penetration Simulation</h4>
<p>
    The code below shows the new version of the function that simulates the penetrations of each attacker.
</p>
<!-- Button to show/hide code -->
<button onclick="toggleCode('simulationCode')">Show Code</button>
<div id="simulationCode" style="display: none;">
    <pre>
        Random rand = new Random();

        // Add series for each attacker
        for (int attacker = 0; attacker < m_attackers; attacker++)
        {
            Series series = new Series("Attacker " + (attacker + 1));
            series.ChartType = SeriesChartType.StepLine;
            series.BorderWidth = 2;
            series.Color = colors[attacker % colors.Length];

            double current_penetration = 0.0; // Current penetration level for this attacker

            // Simulate the penetration attempts for each time interval
            for (int step = 0; step <= n_intervals; step++)
            {
                double time = step * dt;

                // Random chance to have a successful attack (jump) in this interval
                if (rand.NextDouble() < pen_prob)
                {
                    current_penetration += Math.Sqrt(dt);
                }
                else {
                    current_penetration -= Math.Sqrt(dt);
                }


                // Add point to the series
                series.Points.AddXY(time, current_penetration);
            }

            // Store the final penetration for the attacker
            final_penetrations[attacker] = current_penetration;
            chart1.Series.Add(series);
        }
    </pre>
</div>


<h4>Final Result</h4>
<p>
    The screenshot below shows the output of the realized program, using the parameters <strong>m = 25</strong> for the attackers, penetration probability <strong>p = 0.6</strong>, <strong>number of intervals = 2000</strong>, <strong>total time = 20</strong>, <strong>dt = 0.01</strong>.
</p>

<a href="Homework4_chart.png" data-lightbox="result" data-title="Output of the program with m=25, probability=0.6, n_intervals=2000, tot_time=20, dt=0.01">
    <img src="Homework4_chart.png" alt="Output of the program with m=25, probability=0.6, n_intervals=2000, tot_time=20, dt=0.01" style="max-width: 100%; height: auto; margin: 20px 0;">
</a>

<h3>Notes about the simulation</h3>
<h4>Donsker Invariance Principle (Functional Central Limit Theorem)</h4>
<p>
    The Donsker Invariance Principle is a result in probability theory that states that if we take a sum of independent, identically distributed random variables with zero mean and finite variance, the scaled cumulative sum of these variables converges in distribution to a Wiener process (or Brownian motion) as the number of terms goes to infinity. This theorem provides a bridge between discrete random walks and continuous Brownian motion.

    <ul>
        <li>
            <b>Convergence of Random Walks to Brownian Motion</b>: The theorem implies that a properly scaled random walk will behave, in the limit, like a Wiener process. In the context of the plot, each trajectory represents a discrete approximation of a continuous Wiener process. Over time, the paths converge in behavior to that of Brownian motion.
        </li>
        <li>
            <b>Applications of the Wiener Process</b>: The Wiener process is a continuous-time stochastic process that models random behavior in various applications, such as physics (particle diffusion), finance (stock prices), and biology. The functional central limit theorem justifies using the Wiener process as a model for these real-world phenomena, showing that large-scale random systems approximate continuous Brownian paths.
        </li>
        <li>
            <b>Simulating Brownian Motion</b>: The simulation of multiple trajectories over continuous time, as shown in the plot, demonstrates the central limit behavior on a pathwise level. Each path represents one possible outcome of a random process with properties similar to Brownian motion. This aligns with the Donsker Invariance Principle, as the paths collectively approximate the behavior of the Wiener process in a continuous-time framework.
        </li>
    </ul>
</p>

<h4>Significance in Relation to Wiener Process</h4>
<p>
    The Wiener process is a fundamental building block in stochastic calculus and is used to model random continuous processes. The Donsker theorem essentially states that complex discrete systems can approximate the simpler, continuous Wiener process under proper scaling. Thus, the simulation demonstrates how these random paths conform to a continuous stochastic model, reinforcing the idea that discrete, finite-time processes can exhibit behaviors of a continuous process in the limit.
</p>


<script>
    // JavaScript function to toggle visibility of code sections
    function toggleCode(id) {
        var codeBlock = document.getElementById(id);
        if (codeBlock.style.display === "none") {
            codeBlock.style.display = "block";
        } else {
            codeBlock.style.display = "none";
        }
    }
</script>
        
        </section>
        
        
    </div>

    <script src="https://cdn.jsdelivr.net/npm/lightbox2/dist/js/lightbox-plus-jquery.min.js"></script>
</body>
</html>
